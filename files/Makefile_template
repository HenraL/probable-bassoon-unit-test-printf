##
## EPITECH PROJECT, 2022
## B-CPE-101-PAR-1-1-myprintf-henry.letellier
## File description:
## Makefile
##

# The variables in charge of storing the paths to certain files
CODE_ACCESS_FOLDER	=	src/
LIBMY_ACCESS_FOLDER	=	lib/my/

# this is where your files go (in the src/ folder)
SRC	=	$(CODE_ACCESS_FOLDER)*.c	\

# Your lib/my files that can be found in the my folder located in the lib \
folder itself located in the root of your folder.
LIB_MY	=	$(LIBMY_ACCESS_FOLDER)my_swap.c	\
			$(LIBMY_ACCESS_FOLDER)my_isneg.c	\
			$(LIBMY_ACCESS_FOLDER)my_strlen.c	\
			$(LIBMY_ACCESS_FOLDER)my_strstr.c	\
			$(LIBMY_ACCESS_FOLDER)my_getnbr.c	\
			$(LIBMY_ACCESS_FOLDER)my_putstr.c	\
			$(LIBMY_ACCESS_FOLDER)my_revstr.c	\
			$(LIBMY_ACCESS_FOLDER)my_strcat.c	\
			$(LIBMY_ACCESS_FOLDER)my_strcmp.c	\
			$(LIBMY_ACCESS_FOLDER)my_strcpy.c	\
			$(LIBMY_ACCESS_FOLDER)my_strdup.c	\
			$(LIBMY_ACCESS_FOLDER)int_to_hex.c	\
			$(LIBMY_ACCESS_FOLDER)my_put_nbr.c	\
			$(LIBMY_ACCESS_FOLDER)my_putchar.c	\
			$(LIBMY_ACCESS_FOLDER)my_showmem.c	\
			$(LIBMY_ACCESS_FOLDER)my_showstr.c	\
			$(LIBMY_ACCESS_FOLDER)my_strncat.c	\
			$(LIBMY_ACCESS_FOLDER)my_strncmp.c	\
			$(LIBMY_ACCESS_FOLDER)my_strncpy.c	\
			$(LIBMY_ACCESS_FOLDER)nb_to_char.c	\
			$(LIBMY_ACCESS_FOLDER)my_is_prime.c	\
			$(LIBMY_ACCESS_FOLDER)my_str_isnum.c	\
			$(LIBMY_ACCESS_FOLDER)my_strupcase.c	\
			$(LIBMY_ACCESS_FOLDER)concat_params.c	\
			$(LIBMY_ACCESS_FOLDER)my_strlowcase.c	\
			$(LIBMY_ACCESS_FOLDER)my_str_isalpha.c	\
			$(LIBMY_ACCESS_FOLDER)my_str_islower.c	\
			$(LIBMY_ACCESS_FOLDER)my_str_isupper.c	\
			$(LIBMY_ACCESS_FOLDER)my_putnbr_base.c	\
			$(LIBMY_ACCESS_FOLDER)my_strcapitalize.c	\
			$(LIBMY_ACCESS_FOLDER)my_sort_int_array.c	\
			$(LIBMY_ACCESS_FOLDER)my_find_prime_sup.c	\
			$(LIBMY_ACCESS_FOLDER)my_show_word_array.c	\
			$(LIBMY_ACCESS_FOLDER)my_str_isprintable.c	\
			$(LIBMY_ACCESS_FOLDER)my_chr_is_printrable.c	\
			$(LIBMY_ACCESS_FOLDER)my_str_to_word_array.c	\
			$(LIBMY_ACCESS_FOLDER)my_compute_power_rec.c	\
			$(LIBMY_ACCESS_FOLDER)my_compute_square_root.c	\

# The variable in charge of storing the symbol that silences compilations.
SILENT	=	@

# The variable in charge of storing the command used to compile
CC	=	$(SILENT)gcc

# The variable in charge of storing the command in charge of removing files
RM	=	$(SILENT)rm -f

# The variable in charge of storing the command to copy files from one place \
to another.
COPY_FILE	=	$(SILENT)cp -uf

# This is the information that specified where to find the header files
CPPFLAGS	=	-I./include

# This is information that specifies how to treat certain warnings
CFLAGS	=	-Wall -Wextra -lm

# This is where all your .c files get converted to .o files.
OBJ	=	$(SRC:.c=.o)

# The standard epitech library. all the .c files will be compiled and become .o
LIB_MY_OBJ = $(LIB_MY:.c=.o)

# Converting all the .c to .o for the libraries
INNER_LIBS	=	$(LIB_MY_OBJ)

# The synthax required to bind a library to a compilation
LIB	=	-L. -lmy

# The location of the file containing the tests
UNIT_FILE	=	tests/test_my_printf.c

# The required flags for the criterion (in charge of unit testing) library to \
run properly.
UNIT_FLAG	=	--coverage -lcriterion

# The name of the resulting binary for unit testing
UNIT_NAME	=	unit_tests

# The name of the final archive
NAME	=	libmy.a

# The first rule that is called in the makefile when you run 'make'
all: $(NAME)

# Create an archive with the .o files
$(NAME):	update_dep $(OBJ) $(INNER_LIBS)
	$(SILENT)ar rc $(NAME) $(OBJ) $(INNER_LIBS)

# update the header files from the libraries by copying them into the include \
folder.
update_dep:
	$(COPY_FILE) lib/my/my.h include/

# For unit testing (compilation of the program)
for_unit_testing: update_dep all
	$(CC) -o $(UNIT_NAME) $(CFLAGS) $(CPPFLAGS) $(UNIT_FILE) $(LIB) $(UNIT_FLAG)

# clean the temporary files generated by the compilation process
clean:
	$(RM) $(OBJ)
	$(RM) $(INNER_LIBS)

# clean the temporary test files generated by the compilation of the unit test
clean_test: clean
	$(RM) *.gcda
	$(RM) *.gcno

# call the clean function, and then remove the libmy.a archive
fclean: clean
	$(RM) $(NAME)

# call the clean_test and remove the unit_test binary
fclean_test: clean_test
	$(RM) $(UNIT_NAME)

# call the fclean_test then call for_unit_testing
unit_tests: fclean_test for_unit_testing

# call the unit_test binary
run_tests:
	./$(UNIT_NAME)

# call the fclean then call the all rule
re: fclean all

# call the fclean_test then call for_unit_testing
retest: fclean_test for_unit_testing

# Use .PHONY to protect your rules and avoid that a file of the same name to \
considered as a rule.
.PHONY: all \
		update_dep \
		for_unit_testing \
		clean clean_test \
		fclean fclean_test \
		re \
		retest \
		unit_tests \
		run_tests
